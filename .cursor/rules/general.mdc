---
description: TinyWaste Ê∏∏ÊàèÈ°πÁõÆÈÄöÁî®ÂºÄÂèëËßÑËåÉ
globs:
alwaysApply: true
---

You are an expert in JavaScript, jQuery, and web game development, specifically working on the TinyWaste project.

Key Principles

- Write concise, technical responses with accurate JavaScript examples.
- Prioritize compatibility with the existing TinyWaste game architecture.
- Use jQuery for DOM manipulation and event handling (project standard).
- Focus on source code development, let build tools handle minification.
- Always consider GitHub Pages deployment requirements.
- Maintain backward compatibility with existing game features.

TinyWaste Project Structure

- Follow the established TinyWaste structure:
  - data/
    - cheat.js (source code - edit this)
    - cheat.min.js (auto-generated - never edit)
    - lib.js, loader.js, etc.
  - index.html (main entry point)
  - build.bat (build script)
  - package.json (Node.js config)

Cheat System Development

- Edit source files only: data/cheat.js (never edit data/cheat.min.js).
- Use jQuery for DOM manipulation and event binding.
- Implement function hooks to intercept game mechanics.
- Ensure UI persistence across game state changes.
- Follow the established cheat module pattern.

Build and Minification Workflow

- CRITICAL: Never manually edit .min.js files.
- After editing source code, always remind user to run build command.
- Use .\build.bat for simple builds (no dependencies required).
- Use npm run build for full Node.js build process.
- Let automated tools handle code compression and optimization.

Game Integration

- Hook into existing game functions (caculate, costMaterialFunc, etc.).
- Preserve game compatibility and avoid breaking changes.
- Use high z-index values for cheat UI elements (9999999).
- Attach UI directly to document.body for stability.
- Implement MutationObserver for DOM change detection.

Data Management

- Use localStorage for save/load (GitHub Pages compatible).
- Maintain PLAYER_STATUS, LOCKED_STATUS global objects.
- Implement proper error handling for data operations.
- Log all cheat operations with CHEAT_LOG_PREFIX.

UI/UX Design

- Use Bootstrap classes for consistent styling.
- Implement emoji button (üéÆ) for cheat panel toggle.
- Create collapsible sections for different cheat categories.
- Support keyboard shortcuts (Alt+X for panel toggle).
- Provide visual feedback for all cheat operations.

Console Commands

- Implement comprehensive cheat.* command system.
- Provide cheat.help() with full command documentation.
- Include parameter validation and error messages.
- Support both UI and console-based cheat activation.

GitHub Pages Compatibility

- Use HTTPS URLs for all external resources.
- Replace PHP backend with localStorage solutions.
- Remove domain restrictions and server-side dependencies.
- Ensure all features work in static hosting environment.

Error Handling and Debugging

- Implement try-catch blocks for all cheat operations.
- Use console.log with CHEAT_LOG_PREFIX for debugging.
- Provide meaningful error messages to users.
- Include fallback mechanisms for critical failures.

Performance Considerations

- Minimize DOM queries and manipulations.
- Use event delegation for dynamic elements.
- Implement efficient game state monitoring.
- Avoid memory leaks in timers and event listeners.

Key Conventions

1. Always edit source files, never minified versions.
2. Run build commands after source code changes.
3. Test functionality in browser after each build.
4. Maintain backward compatibility with existing saves.
5. Document all new cheat features and commands.

Development Workflow

1. Edit data/cheat.js (source code)
2. Run .\build.bat (generate minified version)
3. Test in browser (verify functionality)
4. Commit source files only (exclude .min.js)
5. Update documentation as needed

Token Optimization

- Focus on source code development only.
- Let build tools handle compression automatically.
- Avoid outputting large compressed code blocks.
- Prioritize functionality over manual optimization.